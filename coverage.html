
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>s3tables: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">s3t/internal/s3tables/creator.go (100.0%)</option>
				
				<option value="file1">s3t/internal/s3tables/errors.go (100.0%)</option>
				
				<option value="file2">s3t/internal/s3tables/lister.go (96.9%)</option>
				
				<option value="file3">s3t/internal/s3tables/navigator.go (92.5%)</option>
				
				<option value="file4">s3t/internal/s3tables/selector.go (22.2%)</option>
				
				<option value="file5">s3t/internal/s3tables/validation.go (100.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package s3tables

import (
        "context"
        "errors"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3tables"
        "github.com/aws/aws-sdk-go-v2/service/s3tables/types"
        "github.com/aws/smithy-go"
)

// S3TablesAPI defines the interface for AWS S3 Tables API operations
type S3TablesAPI interface {
        ListTableBuckets(ctx context.Context, params *s3tables.ListTableBucketsInput, optFns ...func(*s3tables.Options)) (*s3tables.ListTableBucketsOutput, error)
        GetTableBucket(ctx context.Context, params *s3tables.GetTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableBucketOutput, error)
        CreateTableBucket(ctx context.Context, params *s3tables.CreateTableBucketInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateTableBucketOutput, error)
        GetNamespace(ctx context.Context, params *s3tables.GetNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.GetNamespaceOutput, error)
        CreateNamespace(ctx context.Context, params *s3tables.CreateNamespaceInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateNamespaceOutput, error)
        GetTable(ctx context.Context, params *s3tables.GetTableInput, optFns ...func(*s3tables.Options)) (*s3tables.GetTableOutput, error)
        CreateTable(ctx context.Context, params *s3tables.CreateTableInput, optFns ...func(*s3tables.Options)) (*s3tables.CreateTableOutput, error)
        ListNamespaces(ctx context.Context, params *s3tables.ListNamespacesInput, optFns ...func(*s3tables.Options)) (*s3tables.ListNamespacesOutput, error)
        ListTables(ctx context.Context, params *s3tables.ListTablesInput, optFns ...func(*s3tables.Options)) (*s3tables.ListTablesOutput, error)
}

// CreateResult represents the result of resource creation
type CreateResult struct {
        TableBucketARN     string
        TableARN           string
        Messages           []string
        TableBucketCreated bool
        NamespaceCreated   bool
        TableCreated       bool
}

// S3TablesCreator manages S3 Tables resource creation
type S3TablesCreator struct {
        client S3TablesAPI
}

// NewS3TablesCreator creates a new S3TablesCreator instance
func NewS3TablesCreator(client S3TablesAPI) *S3TablesCreator <span class="cov8" title="1">{
        return &amp;S3TablesCreator{client: client}
}</span>

// isNotFoundError checks if the error is a NotFoundException from AWS API
func isNotFoundError(err error) bool <span class="cov8" title="1">{
        var nfe *types.NotFoundException
        if errors.As(err, &amp;nfe) </span><span class="cov8" title="1">{
                return true
        }</span>
        // Also check for smithy API error with NotFound code
        <span class="cov8" title="1">var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov8" title="1">{
                return apiErr.ErrorCode() == "NotFoundException"
        }</span>
        <span class="cov8" title="1">return false</span>
}

// checkTableBucketExists checks if a Table Bucket exists and returns its ARN if it does
// Uses ListTableBuckets with prefix filter to find the bucket by name
func (c *S3TablesCreator) checkTableBucketExists(ctx context.Context, tableBucket string) (exists bool, arn string, err error) <span class="cov8" title="1">{
        output, err := c.client.ListTableBuckets(ctx, &amp;s3tables.ListTableBucketsInput{
                Prefix: aws.String(tableBucket),
        })
        if err != nil </span><span class="cov8" title="1">{
                return false, "", WrapError("ListTableBuckets", err)
        }</span>

        // Find exact match in the results
        <span class="cov8" title="1">for _, bucket := range output.TableBuckets </span><span class="cov8" title="1">{
                if aws.ToString(bucket.Name) == tableBucket </span><span class="cov8" title="1">{
                        return true, aws.ToString(bucket.Arn), nil
                }</span>
        }

        <span class="cov8" title="1">return false, "", nil</span>
}

// checkNamespaceExists checks if a Namespace exists under the given Table Bucket
func (c *S3TablesCreator) checkNamespaceExists(ctx context.Context, tableBucketARN, namespace string) (exists bool, err error) <span class="cov8" title="1">{
        _, err = c.client.GetNamespace(ctx, &amp;s3tables.GetNamespaceInput{
                TableBucketARN: aws.String(tableBucketARN),
                Namespace:      aws.String(namespace),
        })
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">return false, WrapError("GetNamespace", err)</span>
        }
        <span class="cov8" title="1">return true, nil</span>
}

// checkTableExists checks if a Table exists under the given Namespace
func (c *S3TablesCreator) checkTableExists(ctx context.Context, tableBucketARN, namespace, table string) (exists bool, tableARN string, err error) <span class="cov8" title="1">{
        output, err := c.client.GetTable(ctx, &amp;s3tables.GetTableInput{
                TableBucketARN: aws.String(tableBucketARN),
                Namespace:      aws.String(namespace),
                Name:           aws.String(table),
        })
        if err != nil </span><span class="cov8" title="1">{
                if isNotFoundError(err) </span><span class="cov8" title="1">{
                        return false, "", nil
                }</span>
                <span class="cov8" title="1">return false, "", WrapError("GetTable", err)</span>
        }
        <span class="cov8" title="1">return true, aws.ToString(output.TableARN), nil</span>
}

// Create creates S3 Tables resources hierarchically: Table Bucket → Namespace → Table
// It checks for existing resources and only creates what's needed
func (c *S3TablesCreator) Create(ctx context.Context, tableBucket, namespace, table string) (*CreateResult, error) <span class="cov8" title="1">{
        result := &amp;CreateResult{
                Messages: make([]string, 0),
        }

        // Step 1: Check/Create Table Bucket
        tableBucketARN, err := c.ensureTableBucket(ctx, tableBucket, result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Step 2: Check/Create Namespace
        <span class="cov8" title="1">err = c.ensureNamespace(ctx, tableBucketARN, namespace, result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // Step 3: Check/Create Table
        <span class="cov8" title="1">err = c.ensureTable(ctx, tableBucketARN, namespace, table, result)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// ensureTableBucket ensures the Table Bucket exists, creating it if necessary
func (c *S3TablesCreator) ensureTableBucket(ctx context.Context, tableBucket string, result *CreateResult) (string, error) <span class="cov8" title="1">{
        exists, arn, err := c.checkTableBucketExists(ctx, tableBucket)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                result.TableBucketARN = arn
                result.Messages = append(result.Messages, fmt.Sprintf("Table Bucket '%s' already exists", tableBucket))
                return arn, nil
        }</span>

        // Create Table Bucket
        <span class="cov8" title="1">output, err := c.client.CreateTableBucket(ctx, &amp;s3tables.CreateTableBucketInput{
                Name: aws.String(tableBucket),
        })
        if err != nil </span><span class="cov8" title="1">{
                return "", WrapError("CreateTableBucket", err)
        }</span>

        <span class="cov8" title="1">result.TableBucketCreated = true
        result.TableBucketARN = aws.ToString(output.Arn)
        result.Messages = append(result.Messages, fmt.Sprintf("Table Bucket '%s' created", tableBucket))
        return result.TableBucketARN, nil</span>
}

// ensureNamespace ensures the Namespace exists, creating it if necessary
func (c *S3TablesCreator) ensureNamespace(ctx context.Context, tableBucketARN, namespace string, result *CreateResult) error <span class="cov8" title="1">{
        exists, err := c.checkNamespaceExists(ctx, tableBucketARN, namespace)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                result.Messages = append(result.Messages, fmt.Sprintf("Namespace '%s' already exists", namespace))
                return nil
        }</span>

        // Create Namespace
        <span class="cov8" title="1">_, err = c.client.CreateNamespace(ctx, &amp;s3tables.CreateNamespaceInput{
                TableBucketARN: aws.String(tableBucketARN),
                Namespace:      []string{namespace},
        })
        if err != nil </span><span class="cov8" title="1">{
                return WrapError("CreateNamespace", err)
        }</span>

        <span class="cov8" title="1">result.NamespaceCreated = true
        result.Messages = append(result.Messages, fmt.Sprintf("Namespace '%s' created", namespace))
        return nil</span>
}

// ensureTable ensures the Table exists, creating it if necessary
func (c *S3TablesCreator) ensureTable(ctx context.Context, tableBucketARN, namespace, table string, result *CreateResult) error <span class="cov8" title="1">{
        exists, tableARN, err := c.checkTableExists(ctx, tableBucketARN, namespace, table)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if exists </span><span class="cov8" title="1">{
                result.TableARN = tableARN
                result.Messages = append(result.Messages, fmt.Sprintf("Table '%s' already exists", table))
                return nil
        }</span>

        // Create Table
        <span class="cov8" title="1">output, err := c.client.CreateTable(ctx, &amp;s3tables.CreateTableInput{
                TableBucketARN: aws.String(tableBucketARN),
                Namespace:      aws.String(namespace),
                Name:           aws.String(table),
                Format:         types.OpenTableFormatIceberg,
        })
        if err != nil </span><span class="cov8" title="1">{
                return WrapError("CreateTable", err)
        }</span>

        <span class="cov8" title="1">result.TableCreated = true
        result.TableARN = aws.ToString(output.TableARN)
        result.Messages = append(result.Messages, fmt.Sprintf("Table '%s' created", table))
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package s3tables

import (
        "errors"
        "fmt"

        "github.com/aws/aws-sdk-go-v2/service/s3tables/types"
        "github.com/aws/smithy-go"
)

// ErrorType represents the type of error encountered
type ErrorType int

const (
        // ErrorTypeUnknown represents an unknown error type
        ErrorTypeUnknown ErrorType = iota
        // ErrorTypeNotFound represents a resource not found error (404)
        ErrorTypeNotFound
        // ErrorTypeConflict represents a resource conflict error (409)
        ErrorTypeConflict
        // ErrorTypeForbidden represents an authentication/authorization error (403)
        ErrorTypeForbidden
        // ErrorTypeBadRequest represents an invalid input error (400)
        ErrorTypeBadRequest
        // ErrorTypeInternalServer represents a server-side error (500)
        ErrorTypeInternalServer
        // ErrorTypeCredentials represents missing or invalid AWS credentials
        ErrorTypeCredentials
)

// S3TablesError represents a user-friendly error from S3 Tables operations
type S3TablesError struct {
        OriginalErr error
        Operation   string
        Message     string
        Suggestion  string
        Type        ErrorType
}

func (e *S3TablesError) Error() string <span class="cov8" title="1">{
        if e.Suggestion != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("Error: %s: %s - %s", e.Operation, e.Message, e.Suggestion)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Error: %s: %s", e.Operation, e.Message)</span>
}

func (e *S3TablesError) Unwrap() error <span class="cov8" title="1">{
        return e.OriginalErr
}</span>

// WrapError converts an AWS API error to a user-friendly S3TablesError
func WrapError(operation string, err error) error <span class="cov8" title="1">{
        if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s3tErr := &amp;S3TablesError{
                Operation:   operation,
                OriginalErr: err,
        }

        // Check for specific S3 Tables exception types
        var notFoundErr *types.NotFoundException
        var conflictErr *types.ConflictException
        var forbiddenErr *types.ForbiddenException
        var badRequestErr *types.BadRequestException
        var internalErr *types.InternalServerErrorException

        switch </span>{
        case errors.As(err, &amp;notFoundErr):<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeNotFound
                s3tErr.Message = "resource not found"
                s3tErr.Suggestion = "verify the resource name and try again"</span>

        case errors.As(err, &amp;conflictErr):<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeConflict
                s3tErr.Message = "resource already exists"
                s3tErr.Suggestion = "use a different name or check existing resources"</span>

        case errors.As(err, &amp;forbiddenErr):<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeForbidden
                s3tErr.Message = "access denied"
                s3tErr.Suggestion = "check your AWS credentials and permissions"</span>

        case errors.As(err, &amp;badRequestErr):<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeBadRequest
                s3tErr.Message = "invalid request"
                s3tErr.Suggestion = "check your input parameters"</span>

        case errors.As(err, &amp;internalErr):<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeInternalServer
                s3tErr.Message = "AWS service error"
                s3tErr.Suggestion = "please retry the operation"</span>

        default:<span class="cov8" title="1">
                // Check for smithy API errors
                var apiErr smithy.APIError
                if errors.As(err, &amp;apiErr) </span><span class="cov8" title="1">{
                        s3tErr = handleAPIError(operation, apiErr, err)
                }</span> else<span class="cov8" title="1"> {
                        // Check for credential-related errors
                        if isCredentialError(err) </span><span class="cov8" title="1">{
                                s3tErr.Type = ErrorTypeCredentials
                                s3tErr.Message = "AWS credentials not configured"
                                s3tErr.Suggestion = "configure AWS credentials using 'aws configure' or environment variables"
                        }</span> else<span class="cov8" title="1"> {
                                s3tErr.Type = ErrorTypeUnknown
                                s3tErr.Message = err.Error()
                        }</span>
                }
        }

        <span class="cov8" title="1">return s3tErr</span>
}

// handleAPIError handles smithy API errors
func handleAPIError(operation string, apiErr smithy.APIError, originalErr error) *S3TablesError <span class="cov8" title="1">{
        s3tErr := &amp;S3TablesError{
                Operation:   operation,
                OriginalErr: originalErr,
        }

        code := apiErr.ErrorCode()
        switch code </span>{
        case "NotFoundException":<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeNotFound
                s3tErr.Message = "resource not found"
                s3tErr.Suggestion = "verify the resource name and try again"</span>

        case "ConflictException":<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeConflict
                s3tErr.Message = "resource already exists"
                s3tErr.Suggestion = "use a different name or check existing resources"</span>

        case "ForbiddenException", "AccessDeniedException", "AccessDenied":<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeForbidden
                s3tErr.Message = "access denied"
                s3tErr.Suggestion = "check your AWS credentials and permissions"</span>

        case "BadRequestException", "ValidationException":<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeBadRequest
                s3tErr.Message = "invalid request"
                if msg := apiErr.ErrorMessage(); msg != "" </span><span class="cov8" title="1">{
                        s3tErr.Message = msg
                }</span>
                <span class="cov8" title="1">s3tErr.Suggestion = "check your input parameters"</span>

        case "InternalServerErrorException", "InternalServerError", "ServiceException":<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeInternalServer
                s3tErr.Message = "AWS service error"
                s3tErr.Suggestion = "please retry the operation"</span>

        case "UnrecognizedClientException", "InvalidSignatureException":<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeCredentials
                s3tErr.Message = "invalid AWS credentials"
                s3tErr.Suggestion = "check your AWS credentials configuration"</span>

        default:<span class="cov8" title="1">
                s3tErr.Type = ErrorTypeUnknown
                s3tErr.Message = apiErr.ErrorMessage()
                if s3tErr.Message == "" </span><span class="cov8" title="1">{
                        s3tErr.Message = code
                }</span>
        }

        <span class="cov8" title="1">return s3tErr</span>
}

// isCredentialError checks if the error is related to AWS credentials
func isCredentialError(err error) bool <span class="cov8" title="1">{
        errStr := err.Error()
        credentialKeywords := []string{
                "no credentials",
                "credential",
                "NoCredentialProviders",
                "SharedConfigProfileNotExist",
                "failed to refresh cached credentials",
        }
        for _, keyword := range credentialKeywords </span><span class="cov8" title="1">{
                if containsIgnoreCase(errStr, keyword) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// containsIgnoreCase checks if s contains substr (case-insensitive)
func containsIgnoreCase(s, substr string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(substr) &amp;&amp; (s == substr || len(substr) == 0 ||
                (len(s) &gt; 0 &amp;&amp; containsIgnoreCaseHelper(s, substr)))
}</span>

func containsIgnoreCaseHelper(s, substr string) bool <span class="cov8" title="1">{
        for i := 0; i &lt;= len(s)-len(substr); i++ </span><span class="cov8" title="1">{
                if equalFoldAt(s, i, substr) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func equalFoldAt(s string, start int, substr string) bool <span class="cov8" title="1">{
        for j := 0; j &lt; len(substr); j++ </span><span class="cov8" title="1">{
                c1 := s[start+j]
                c2 := substr[j]
                if c1 != c2 &amp;&amp; toLower(c1) != toLower(c2) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func toLower(c byte) byte <span class="cov8" title="1">{
        if c &gt;= 'A' &amp;&amp; c &lt;= 'Z' </span><span class="cov8" title="1">{
                return c + 32
        }</span>
        <span class="cov8" title="1">return c</span>
}

// IsNotFoundError checks if the error is a not found error
func IsNotFoundError(err error) bool <span class="cov8" title="1">{
        var s3tErr *S3TablesError
        if errors.As(err, &amp;s3tErr) </span><span class="cov8" title="1">{
                return s3tErr.Type == ErrorTypeNotFound
        }</span>
        // Also check original AWS error types
        <span class="cov8" title="1">var nfe *types.NotFoundException
        if errors.As(err, &amp;nfe) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">var apiErr smithy.APIError
        if errors.As(err, &amp;apiErr) </span><span class="cov8" title="1">{
                return apiErr.ErrorCode() == "NotFoundException"
        }</span>
        <span class="cov8" title="1">return false</span>
}

// IsConflictError checks if the error is a conflict error
func IsConflictError(err error) bool <span class="cov8" title="1">{
        var s3tErr *S3TablesError
        if errors.As(err, &amp;s3tErr) </span><span class="cov8" title="1">{
                return s3tErr.Type == ErrorTypeConflict
        }</span>
        <span class="cov8" title="1">var ce *types.ConflictException
        return errors.As(err, &amp;ce)</span>
}

// IsCredentialError checks if the error is a credential error
func IsCredentialError(err error) bool <span class="cov8" title="1">{
        var s3tErr *S3TablesError
        if errors.As(err, &amp;s3tErr) </span><span class="cov8" title="1">{
                return s3tErr.Type == ErrorTypeCredentials
        }</span>
        <span class="cov8" title="1">return isCredentialError(err)</span>
}

// GetErrorType returns the error type from an error
func GetErrorType(err error) ErrorType <span class="cov8" title="1">{
        var s3tErr *S3TablesError
        if errors.As(err, &amp;s3tErr) </span><span class="cov8" title="1">{
                return s3tErr.Type
        }</span>
        <span class="cov8" title="1">return ErrorTypeUnknown</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package s3tables

import (
        "context"
        "fmt"
        "time"

        "github.com/aws/aws-sdk-go-v2/aws"
        "github.com/aws/aws-sdk-go-v2/service/s3tables"
)

// TableBucketInfo represents a table bucket with its metadata
type TableBucketInfo struct {
        Name      string
        ARN       string
        CreatedAt time.Time
}

// NamespaceInfo represents a namespace with its metadata
type NamespaceInfo struct {
        Name      string
        CreatedAt time.Time
}

// TableInfo represents a table with its metadata
type TableInfo struct {
        Name      string
        ARN       string
        Namespace string
        CreatedAt time.Time
        Type      string
}

// S3TablesLister manages S3 Tables resource listing
type S3TablesLister struct {
        client S3TablesAPI
}

// NewS3TablesLister creates a new S3TablesLister instance
func NewS3TablesLister(client S3TablesAPI) *S3TablesLister <span class="cov8" title="1">{
        return &amp;S3TablesLister{client: client}
}</span>

// ListTableBucketsAll retrieves all table buckets with pagination
func (l *S3TablesLister) ListTableBucketsAll(ctx context.Context, prefix string) ([]TableBucketInfo, error) <span class="cov8" title="1">{
        var buckets []TableBucketInfo
        var continuationToken *string

        for </span><span class="cov8" title="1">{
                input := &amp;s3tables.ListTableBucketsInput{
                        ContinuationToken: continuationToken,
                }
                if prefix != "" </span><span class="cov8" title="1">{
                        input.Prefix = aws.String(prefix)
                }</span>

                <span class="cov8" title="1">output, err := l.client.ListTableBuckets(ctx, input)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, WrapError("ListTableBuckets", err)
                }</span>

                <span class="cov8" title="1">for _, bucket := range output.TableBuckets </span><span class="cov8" title="1">{
                        buckets = append(buckets, TableBucketInfo{
                                Name:      aws.ToString(bucket.Name),
                                ARN:       aws.ToString(bucket.Arn),
                                CreatedAt: aws.ToTime(bucket.CreatedAt),
                        })
                }</span>

                <span class="cov8" title="1">if output.ContinuationToken == nil || *output.ContinuationToken == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">continuationToken = output.ContinuationToken</span>
        }

        <span class="cov8" title="1">return buckets, nil</span>
}

// ListNamespacesAll retrieves all namespaces in a table bucket with pagination
func (l *S3TablesLister) ListNamespacesAll(ctx context.Context, tableBucketARN, prefix string) ([]NamespaceInfo, error) <span class="cov8" title="1">{
        var namespaces []NamespaceInfo
        var continuationToken *string

        for </span><span class="cov8" title="1">{
                input := &amp;s3tables.ListNamespacesInput{
                        TableBucketARN:    aws.String(tableBucketARN),
                        ContinuationToken: continuationToken,
                }
                if prefix != "" </span><span class="cov0" title="0">{
                        input.Prefix = aws.String(prefix)
                }</span>

                <span class="cov8" title="1">output, err := l.client.ListNamespaces(ctx, input)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, WrapError("ListNamespaces", err)
                }</span>

                <span class="cov8" title="1">for _, ns := range output.Namespaces </span><span class="cov8" title="1">{
                        var name string
                        if len(ns.Namespace) &gt; 0 </span><span class="cov8" title="1">{
                                name = ns.Namespace[0]
                        }</span>
                        <span class="cov8" title="1">namespaces = append(namespaces, NamespaceInfo{
                                Name:      name,
                                CreatedAt: aws.ToTime(ns.CreatedAt),
                        })</span>
                }

                <span class="cov8" title="1">if output.ContinuationToken == nil || *output.ContinuationToken == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">continuationToken = output.ContinuationToken</span>
        }

        <span class="cov8" title="1">return namespaces, nil</span>
}

// ListTablesAll retrieves all tables in a namespace with pagination
func (l *S3TablesLister) ListTablesAll(ctx context.Context, tableBucketARN, namespace, prefix string) ([]TableInfo, error) <span class="cov8" title="1">{
        var tables []TableInfo
        var continuationToken *string

        for </span><span class="cov8" title="1">{
                input := &amp;s3tables.ListTablesInput{
                        TableBucketARN:    aws.String(tableBucketARN),
                        Namespace:         aws.String(namespace),
                        ContinuationToken: continuationToken,
                }
                if prefix != "" </span><span class="cov0" title="0">{
                        input.Prefix = aws.String(prefix)
                }</span>

                <span class="cov8" title="1">output, err := l.client.ListTables(ctx, input)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, WrapError("ListTables", err)
                }</span>

                <span class="cov8" title="1">for _, tbl := range output.Tables </span><span class="cov8" title="1">{
                        var ns string
                        if len(tbl.Namespace) &gt; 0 </span><span class="cov8" title="1">{
                                ns = tbl.Namespace[0]
                        }</span>
                        <span class="cov8" title="1">tables = append(tables, TableInfo{
                                Name:      aws.ToString(tbl.Name),
                                ARN:       aws.ToString(tbl.TableARN),
                                Namespace: ns,
                                CreatedAt: aws.ToTime(tbl.CreatedAt),
                                Type:      string(tbl.Type),
                        })</span>
                }

                <span class="cov8" title="1">if output.ContinuationToken == nil || *output.ContinuationToken == "" </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">continuationToken = output.ContinuationToken</span>
        }

        <span class="cov8" title="1">return tables, nil</span>
}

// GetTableDetails retrieves detailed information about a specific table
func (l *S3TablesLister) GetTableDetails(ctx context.Context, tableBucketARN, namespace, table string) (*TableInfo, error) <span class="cov8" title="1">{
        input := &amp;s3tables.GetTableInput{
                TableBucketARN: aws.String(tableBucketARN),
                Namespace:      aws.String(namespace),
                Name:           aws.String(table),
        }

        output, err := l.client.GetTable(ctx, input)
        if err != nil </span><span class="cov8" title="1">{
                return nil, WrapError("GetTable", err)
        }</span>

        <span class="cov8" title="1">return &amp;TableInfo{
                Name:      aws.ToString(output.Name),
                ARN:       aws.ToString(output.TableARN),
                Namespace: namespace,
                CreatedAt: aws.ToTime(output.CreatedAt),
                Type:      string(output.Type),
        }, nil</span>
}

// GetTableBucketARN retrieves the ARN for a table bucket by name
func (l *S3TablesLister) GetTableBucketARN(ctx context.Context, tableBucketName string) (string, error) <span class="cov8" title="1">{
        buckets, err := l.ListTableBucketsAll(ctx, tableBucketName)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">for _, bucket := range buckets </span><span class="cov8" title="1">{
                if bucket.Name == tableBucketName </span><span class="cov8" title="1">{
                        return bucket.ARN, nil
                }</span>
        }

        <span class="cov8" title="1">return "", &amp;S3TablesError{
                Operation:  "GetTableBucketARN",
                Message:    fmt.Sprintf("table bucket '%s' not found", tableBucketName),
                Suggestion: "verify the table bucket name and try again",
                Type:       ErrorTypeNotFound,
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package s3tables

import (
        "context"
        "fmt"
)

// NavigationLevel represents the current navigation level
type NavigationLevel int

const (
        LevelTableBucket NavigationLevel = iota
        LevelNamespace
        LevelTable
)

// String returns the string representation of NavigationLevel
func (l NavigationLevel) String() string <span class="cov8" title="1">{
        switch l </span>{
        case LevelTableBucket:<span class="cov8" title="1">
                return "TableBucket"</span>
        case LevelNamespace:<span class="cov8" title="1">
                return "Namespace"</span>
        case LevelTable:<span class="cov8" title="1">
                return "Table"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// NavigationAction represents the action taken by the user
type NavigationAction int

const (
        ActionSelect NavigationAction = iota // アイテムを選択
        ActionBack                           // ESC で戻る
        ActionExit                           // 終了
)

// String returns the string representation of NavigationAction
func (a NavigationAction) String() string <span class="cov8" title="1">{
        switch a </span>{
        case ActionSelect:<span class="cov8" title="1">
                return "Select"</span>
        case ActionBack:<span class="cov8" title="1">
                return "Back"</span>
        case ActionExit:<span class="cov8" title="1">
                return "Exit"</span>
        default:<span class="cov8" title="1">
                return "Unknown"</span>
        }
}

// NavigationState holds the current navigation state and cached data
type NavigationState struct {
        Level             NavigationLevel
        TableBuckets      []TableBucketInfo // キャッシュされた Table Bucket 一覧
        Namespaces        []NamespaceInfo   // キャッシュされた Namespace 一覧
        Tables            []TableInfo       // キャッシュされた Table 一覧
        SelectedBucket    string            // 選択された Table Bucket 名
        SelectedBucketARN string            // 選択された Table Bucket ARN
        SelectedNamespace string            // 選択された Namespace 名
}

// NavigationController manages hierarchical navigation
type NavigationController struct {
        lister   *S3TablesLister
        selector InteractiveSelector
        state    *NavigationState
}

// NewNavigationController creates a new NavigationController
func NewNavigationController(lister *S3TablesLister, selector InteractiveSelector) *NavigationController <span class="cov8" title="1">{
        return &amp;NavigationController{
                lister:   lister,
                selector: selector,
                state:    &amp;NavigationState{},
        }
}</span>

// GetState returns the current navigation state
func (c *NavigationController) GetState() *NavigationState <span class="cov8" title="1">{
        return c.state
}</span>

// SetInitialState sets the initial state for navigation
func (c *NavigationController) SetInitialState(bucketName, bucketARN, namespace string) <span class="cov8" title="1">{
        c.state.SelectedBucket = bucketName
        c.state.SelectedBucketARN = bucketARN
        c.state.SelectedNamespace = namespace
}</span>

// Navigate starts the navigation from the specified level
func (c *NavigationController) Navigate(ctx context.Context, startLevel NavigationLevel) error <span class="cov8" title="1">{
        c.state.Level = startLevel

        for </span><span class="cov8" title="1">{
                var action NavigationAction
                var err error

                switch c.state.Level </span>{
                case LevelTableBucket:<span class="cov8" title="1">
                        action, err = c.navigateTableBuckets(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if action == ActionBack || action == ActionExit </span><span class="cov8" title="1">{
                                return nil // Exit application
                        }</span>
                        <span class="cov8" title="1">if action == ActionSelect </span><span class="cov8" title="1">{
                                c.state.Level = LevelNamespace
                        }</span>

                case LevelNamespace:<span class="cov8" title="1">
                        action, err = c.navigateNamespaces(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if action == ActionExit </span><span class="cov8" title="1">{
                                return nil // Exit application
                        }</span>
                        <span class="cov8" title="1">if action == ActionBack </span><span class="cov8" title="1">{
                                c.state.Level = LevelTableBucket
                                continue</span>
                        }
                        <span class="cov8" title="1">if action == ActionSelect </span><span class="cov8" title="1">{
                                c.state.Level = LevelTable
                        }</span>

                case LevelTable:<span class="cov8" title="1">
                        action, err = c.navigateTables(ctx)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if action == ActionExit </span><span class="cov8" title="1">{
                                return nil // Exit application
                        }</span>
                        <span class="cov8" title="1">if action == ActionBack </span><span class="cov8" title="1">{
                                c.state.Level = LevelNamespace
                                continue</span>
                        }
                        // Table 選択後は詳細表示して終了
                        <span class="cov8" title="1">return nil</span>
                }
        }
}

// navigateTableBuckets handles Table Bucket level navigation
func (c *NavigationController) navigateTableBuckets(ctx context.Context) (NavigationAction, error) <span class="cov8" title="1">{
        // Fetch table buckets if not cached
        if c.state.TableBuckets == nil </span><span class="cov8" title="1">{
                buckets, err := c.lister.ListTableBucketsAll(ctx, "")
                if err != nil </span><span class="cov8" title="1">{
                        return ActionExit, err
                }</span>
                <span class="cov8" title="1">c.state.TableBuckets = buckets</span>
        }

        <span class="cov8" title="1">if len(c.state.TableBuckets) == 0 </span><span class="cov0" title="0">{
                fmt.Println("No table buckets found")
                return ActionExit, nil
        }</span>

        // Extract names for selection
        <span class="cov8" title="1">names := make([]string, len(c.state.TableBuckets))
        for i, bucket := range c.state.TableBuckets </span><span class="cov8" title="1">{
                names[i] = bucket.Name
        }</span>

        // No back option at top level
        <span class="cov8" title="1">result, err := c.selector.SelectWithFilter("Select Table Bucket", names, false)
        if err != nil </span><span class="cov8" title="1">{
                return ActionExit, err
        }</span>

        <span class="cov8" title="1">if result.Action == ActionBack || result.Action == ActionExit </span><span class="cov8" title="1">{
                return result.Action, nil
        }</span>

        // Find selected bucket and store ARN
        <span class="cov8" title="1">for _, bucket := range c.state.TableBuckets </span><span class="cov8" title="1">{
                if bucket.Name == result.Selected </span><span class="cov8" title="1">{
                        c.state.SelectedBucket = bucket.Name
                        c.state.SelectedBucketARN = bucket.ARN
                        break</span>
                }
        }

        // Clear namespace cache when bucket changes
        <span class="cov8" title="1">c.state.Namespaces = nil
        c.state.Tables = nil

        return ActionSelect, nil</span>
}

// navigateNamespaces handles Namespace level navigation
func (c *NavigationController) navigateNamespaces(ctx context.Context) (NavigationAction, error) <span class="cov8" title="1">{
        // Fetch namespaces if not cached
        if c.state.Namespaces == nil </span><span class="cov8" title="1">{
                namespaces, err := c.lister.ListNamespacesAll(ctx, c.state.SelectedBucketARN, "")
                if err != nil </span><span class="cov8" title="1">{
                        return ActionExit, err
                }</span>
                <span class="cov8" title="1">c.state.Namespaces = namespaces</span>
        }

        <span class="cov8" title="1">if len(c.state.Namespaces) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No namespaces found in table bucket '%s'\n", c.state.SelectedBucket)
                return ActionBack, nil
        }</span>

        // Extract names for selection
        <span class="cov8" title="1">names := make([]string, len(c.state.Namespaces))
        for i, ns := range c.state.Namespaces </span><span class="cov8" title="1">{
                names[i] = ns.Name
        }</span>

        // Show back option to return to table bucket selection
        <span class="cov8" title="1">result, err := c.selector.SelectWithFilter("Select Namespace", names, true)
        if err != nil </span><span class="cov8" title="1">{
                return ActionExit, err
        }</span>

        <span class="cov8" title="1">if result.Action == ActionBack </span><span class="cov8" title="1">{
                return ActionBack, nil
        }</span>
        <span class="cov8" title="1">if result.Action == ActionExit </span><span class="cov8" title="1">{
                return ActionExit, nil
        }</span>

        <span class="cov8" title="1">c.state.SelectedNamespace = result.Selected

        // Clear tables cache when namespace changes
        c.state.Tables = nil

        return ActionSelect, nil</span>
}

// navigateTables handles Table level navigation
func (c *NavigationController) navigateTables(ctx context.Context) (NavigationAction, error) <span class="cov8" title="1">{
        // Fetch tables if not cached
        if c.state.Tables == nil </span><span class="cov8" title="1">{
                tables, err := c.lister.ListTablesAll(ctx, c.state.SelectedBucketARN, c.state.SelectedNamespace, "")
                if err != nil </span><span class="cov8" title="1">{
                        return ActionExit, err
                }</span>
                <span class="cov8" title="1">c.state.Tables = tables</span>
        }

        <span class="cov8" title="1">if len(c.state.Tables) == 0 </span><span class="cov0" title="0">{
                fmt.Printf("No tables found in namespace '%s'\n", c.state.SelectedNamespace)
                return ActionBack, nil
        }</span>

        // Extract names for selection
        <span class="cov8" title="1">names := make([]string, len(c.state.Tables))
        for i, tbl := range c.state.Tables </span><span class="cov8" title="1">{
                names[i] = tbl.Name
        }</span>

        // Show back option to return to namespace selection
        <span class="cov8" title="1">result, err := c.selector.SelectWithFilter("Select Table", names, true)
        if err != nil </span><span class="cov8" title="1">{
                return ActionExit, err
        }</span>

        <span class="cov8" title="1">if result.Action == ActionBack </span><span class="cov8" title="1">{
                return ActionBack, nil
        }</span>
        <span class="cov8" title="1">if result.Action == ActionExit </span><span class="cov8" title="1">{
                return ActionExit, nil
        }</span>

        // Display table details
        <span class="cov8" title="1">for _, tbl := range c.state.Tables </span><span class="cov8" title="1">{
                if tbl.Name == result.Selected </span><span class="cov8" title="1">{
                        c.displayTableDetails(&amp;tbl)
                        break</span>
                }
        }

        <span class="cov8" title="1">return ActionSelect, nil</span>
}

// displayTableDetails prints the details of a table
func (c *NavigationController) displayTableDetails(tbl *TableInfo) <span class="cov8" title="1">{
        fmt.Printf("\nTable Details:\n")
        fmt.Printf("  Name:      %s\n", tbl.Name)
        fmt.Printf("  ARN:       %s\n", tbl.ARN)
        fmt.Printf("  Namespace: %s\n", tbl.Namespace)
        fmt.Printf("  Type:      %s\n", tbl.Type)
        fmt.Printf("  Created:   %s\n", tbl.CreatedAt.Format("2006-01-02 15:04:05"))
}</span>
</pre>
		
		<pre class="file" id="file4" style="display: none">package s3tables

import (
        "fmt"
        "strings"

        "github.com/manifoldco/promptui"
)

// SelectionResult represents the result of a selection
type SelectionResult struct {
        Selected string           // 選択されたアイテム
        Action   NavigationAction // 実行されたアクション
}

// InteractiveSelector provides interactive selection with filtering
type InteractiveSelector interface {
        // SelectWithFilter displays items with real-time filtering
        // showBack adds a ".. (Back)" option at the top when true
        // Returns the selected item and the action taken
        SelectWithFilter(label string, items []string, showBack bool) (*SelectionResult, error)
}

// Selector provides interactive selection UI (legacy interface)
type Selector interface {
        // Select displays items and returns the selected item
        Select(label string, items []string) (string, error)
}

// PromptSelector implements Selector using promptui
type PromptSelector struct{}

// NewPromptSelector creates a new PromptSelector
func NewPromptSelector() *PromptSelector <span class="cov8" title="1">{
        return &amp;PromptSelector{}
}</span>

// Select displays a selection prompt and returns the chosen item
func (s *PromptSelector) Select(label string, items []string) (string, error) <span class="cov8" title="1">{
        if len(items) == 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("no items to select")
        }</span>

        <span class="cov0" title="0">prompt := promptui.Select{
                Label: label,
                Items: items,
                Size:  10,
        }

        idx, _, err := prompt.Run()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("selection failed: %w", err)
        }</span>

        <span class="cov0" title="0">return items[idx], nil</span>
}

// BackOption is the special option for navigating back
const BackOption = ".. (Back)"

// FilterablePromptSelector implements InteractiveSelector with filtering
type FilterablePromptSelector struct{}

// NewFilterablePromptSelector creates a new FilterablePromptSelector
func NewFilterablePromptSelector() *FilterablePromptSelector <span class="cov8" title="1">{
        return &amp;FilterablePromptSelector{}
}</span>

// SelectWithFilter displays a selection prompt with real-time filtering
// Uses promptui's Searcher feature for case-insensitive substring matching
// Selecting ".. (Back)" returns ActionBack
func (s *FilterablePromptSelector) SelectWithFilter(label string, items []string, showBack bool) (*SelectionResult, error) <span class="cov8" title="1">{
        if len(items) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("no items to select")
        }</span>

        // Prepend back option if enabled
        <span class="cov0" title="0">displayItems := items
        if showBack </span><span class="cov0" title="0">{
                displayItems = append([]string{BackOption}, items...)
        }</span>

        // Searcher function for real-time filtering
        // Automatically performs substring matching (equivalent to *input* pattern)
        <span class="cov0" title="0">searcher := func(input string, index int) bool </span><span class="cov0" title="0">{
                item := strings.ToLower(displayItems[index])
                input = strings.ToLower(input)
                // Automatic substring search (case-insensitive)
                return strings.Contains(item, input)
        }</span>

        <span class="cov0" title="0">prompt := promptui.Select{
                Label:             label,
                Items:             displayItems,
                Size:              10,
                Searcher:          searcher,
                StartInSearchMode: false,
        }

        idx, selected, err := prompt.Run()
        if err != nil </span><span class="cov0" title="0">{
                // Ctrl+C triggers ErrInterrupt - treat as exit
                if err == promptui.ErrInterrupt </span><span class="cov0" title="0">{
                        return &amp;SelectionResult{Action: ActionExit}, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("selection failed: %w", err)</span>
        }

        // Check if back option was selected
        <span class="cov0" title="0">if showBack &amp;&amp; idx == 0 </span><span class="cov0" title="0">{
                return &amp;SelectionResult{Action: ActionBack}, nil
        }</span>

        <span class="cov0" title="0">return &amp;SelectionResult{
                Selected: selected,
                Action:   ActionSelect,
        }, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package s3tables

import (
        "fmt"
        "regexp"
)

var (
        // TableBucket: 3-63 characters, lowercase letters, numbers, and hyphens
        tableBucketPattern = regexp.MustCompile(`^[0-9a-z-]+$`)
        // Namespace: 1-255 characters, lowercase letters, numbers, and underscores
        namespacePattern = regexp.MustCompile(`^[0-9a-z_]+$`)
        // Table: 1-255 characters, lowercase letters, numbers, and underscores
        tablePattern = regexp.MustCompile(`^[0-9a-z_]+$`)
)

// ValidationError represents a validation error with field name and reason
type ValidationError struct {
        Field   string
        Message string
}

func (e *ValidationError) Error() string <span class="cov8" title="1">{
        return fmt.Sprintf("invalid %s: %s", e.Field, e.Message)
}</span>

// ValidateTableBucket validates a Table Bucket name according to AWS API constraints
// - Length: 3-63 characters
// - Pattern: lowercase letters, numbers, and hyphens only
func ValidateTableBucket(name string) error <span class="cov8" title="1">{
        if len(name) &lt; 3 </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "table-bucket",
                        Message: "must be at least 3 characters",
                }
        }</span>
        <span class="cov8" title="1">if len(name) &gt; 63 </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "table-bucket",
                        Message: "must be at most 63 characters",
                }
        }</span>
        <span class="cov8" title="1">if !tableBucketPattern.MatchString(name) </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "table-bucket",
                        Message: "must contain only lowercase letters, numbers, and hyphens",
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateNamespace validates a Namespace name according to AWS API constraints
// - Length: 1-255 characters
// - Pattern: lowercase letters, numbers, and underscores only
func ValidateNamespace(name string) error <span class="cov8" title="1">{
        if len(name) &lt; 1 </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "namespace",
                        Message: "must be at least 1 character",
                }
        }</span>
        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "namespace",
                        Message: "must be at most 255 characters",
                }
        }</span>
        <span class="cov8" title="1">if !namespacePattern.MatchString(name) </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "namespace",
                        Message: "must contain only lowercase letters, numbers, and underscores",
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateTable validates a Table name according to AWS API constraints
// - Length: 1-255 characters
// - Pattern: lowercase letters, numbers, and underscores only
func ValidateTable(name string) error <span class="cov8" title="1">{
        if len(name) &lt; 1 </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "table",
                        Message: "must be at least 1 character",
                }
        }</span>
        <span class="cov8" title="1">if len(name) &gt; 255 </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "table",
                        Message: "must be at most 255 characters",
                }
        }</span>
        <span class="cov8" title="1">if !tablePattern.MatchString(name) </span><span class="cov8" title="1">{
                return &amp;ValidationError{
                        Field:   "table",
                        Message: "must contain only lowercase letters, numbers, and underscores",
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ValidateAll validates all input parameters for the create command
func ValidateAll(tableBucket, namespace, table string) error <span class="cov8" title="1">{
        if err := ValidateTableBucket(tableBucket); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateNamespace(namespace); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ValidateTable(table); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
